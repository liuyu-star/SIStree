#' Sure Independence Screening for Forest Structures
#'
#' The sure independence screening forest (SISforest) is an ensemble of multiple SIStrees generated by sample bagging. SISforest performs slightly better than SIStree, but consumes significantly more time.
#'
#' @param formula Object of class \code{formula} with a response describing the model to fit. If this is a data frame, it is taken as the model frame. (see \code{\link{model.frame}})
#' @param data Training data of class \code{data.frame} containing variables named in the formula. If \code{data} is missing it is obtained from the current environment by \code{formula}.
#' @param X An n by d numeric matrix (preferable) or data frame.
#' @param y A response vector of length n.
#' @param criteria The independence measurement criteria used for splitting the nodes. We provided seven criteria (default criteria='DCor'), for details see \code{\link{Split}}.
#' @param ntrees The number of trees in the forest (default 100).
#' @param storeOOB If TRUE then the samples omitted during the creation of a tree are stored as part of the tree (default TRUE).
#' @param replacement if TRUE then n samples are chosen, with replacement, from training data (default TRUE).
#' @param stratify If TRUE then class sample proportions are maintained during the random sampling. Ignored if replacement = FALSE (default TRUE).
#' @param ratOOB  Ratio of 'out-of-bag' (default 1/3).
#' @param parallel Parallel computing or not (default TRUE).
#' @param numCores Number of cores to be used for parallel computing (default \code{Inf}).
#' @param MaxDepth The maximum depth of the tree (default \code{Inf}).
#' @param numNode Number of nodes that can be used by the tree (default \code{Inf}).
#' @param MinLeaf Minimum sample size for leaf nodes (Default 10).
#' @param subset An index vector indicating which rows should be used. (NOTE: If given, this argument must be named.)
#' @param weights Vector of non-negative observational weights; fractional weights are allowed (default NULL).
#' @param na.action A function to specify the action to be taken if NAs are found. (NOTE: If given, this argument must be named.)
#' @param Xscale Predictor standardization methods. " Min-max" (default), "Quantile", "No" denote Min-max transformation, Quantile transformation and No transformation respectively.
#' @param ... Optional parameters to be passed to the low level function.
#'
#' @return An object of class SISforest Containing a list components:
#' \itemize{
#' \item{\code{call}: The original call to SISforest.}
#' \item{\code{terms}: An object of class \code{c("terms", "formula")} (see \code{\link{terms.object}}) summarizing the formula. Used by various methods, but typically not of direct relevance to users.}
#' \item{\code{data}: The list of data related parameters used to build the forest.}
#' \item{\code{tree}: The list of tree related parameters used to build the tree.}
#' \item{\code{forest}: The list of forest related parameters used to build the forest.}
#' \item{\code{VarImp}: Variable screening results for forest structure.
#' \itemize{
#' \item{\code{rank.SISforest}: Variable ranking results for sure independence screening forest.}
#' \item{\code{rank.SIStree}: Variable ranking results for each sure independence screening tree.}
#' \item{\code{SISforest}: The correlation coefficients of each variable with the response for sure independence screening forest.}
#' }}
#' }
#'
#' @seealso \code{\link{SIStree}}
#'
#' @author Yu Liu and Zhibo Cai
#' @keywords forest
#'
#' @examples
#' #simulation data with continuous response.
#' X = matrix(rnorm(100*1000), 100, 1000)
#' y = X[,1] + X[,2]^2 + 2*X[,4]*X[,5] + rnorm(100)
#' \dontrun{
#' sis = SISforest(X, y, parallel=FALSE)
#' # show the first 20 variables ranked by SISforest
#' sis$VarImp$rank.SISforest[1:20]
#' }
#'
#' #real data with categorical response.
#' data(breast_cancer)
#'
#' sis <- SISforest(as.factor(diagnosis) ~ ., breast_cancer[,-1],
#'        criteria='Gini', parallel=FALSE)
#' #show variables ranked by SISforest
#' sis$VarImp$rank.SISforest
#'
#' @export
SISforest <- function(X, ...) {
  UseMethod("SISforest")
}


#' @rdname SISforest
#' @method SISforest formula
#' @aliases SISforest.formula
#' @export
SISforest.formula <- function(formula, data = NULL, criteria=c('DCor',"Pearson", "CvM","MI","HHG","HSIC","Gini")[1],
                              ntrees = 100, storeOOB = TRUE, replacement = TRUE, stratify = TRUE, ratOOB = 0.368, parallel = TRUE,
                              numCores = Inf, MaxDepth = Inf, numNode = Inf, MinLeaf = 10, subset = NULL, weights = NULL, na.action = na.fail,
                              Xscale = "Min-max", ...) {
  Call <- match.call()
  indx <- match(c("formula", "data", "subset", "na.action"), names(Call), nomatch = 0L) # , "weights"
  # formula=X
  if (indx[[1]] == 0) {
    stop("A 'formula' or 'X', 'y' argument is required")
  } else if (indx[[2]] == 0) {
    # stop("a 'data' argument is required")
    # data <- environment(formula)
    X <- eval(formula[[3]])
    y <- eval(formula[[2]])
    if (sum(match(class(X), c("data.frame", "matrix"), nomatch = 0L)) == 0) {
      stop("argument 'X' can only be the classes 'data.frame' or 'matrix'")
    }
    if (ncol(X) == 1) {
      stop("argument 'X' dimension must exceed 1")
    }

    if (is.null(colnames(X))) {
      colnames(X) <- paste0("X", seq_len(ncol(X)))
    }
    data <- data.frame(y, X)
    # varName <- colnames(X)
    yname <- ls(envir = .GlobalEnv)
    colnames(data) <- c(as.character(formula)[2], colnames(X))
    formula <- as.formula(paste0(as.character(formula)[2], "~."))
    Call$formula <- formula
    Call$data <- quote(data)
  } else {
    if (sum(match(class(data), c("data.frame"), nomatch = 0L)) == 0) {
      stop("argument 'data' can only be the classe 'data.frame'")
    }
    if (ncol(data) == 2) {
      stop("The predictor dimension of argument 'data' must exceed 1.")
    }

    # varName <- setdiff(colnames(data), as.character(formula)[2])
    # X <- data[, varName]
    # y <- data[, as.character(formula)[2]]
    # Call$data <- quote(data)
    yname <- colnames(data)
    data <- model.frame(formula, data, drop.unused.levels = TRUE)
    y <- data[, 1]
    X <- data[, -1]
    Call$data <- quote(data)
  }

  varName <- colnames(X)
  yname <- names(unlist(sapply(yname, function(x) grep(x, as.character(formula)[2]))))
  yname <- yname[which.max(nchar(yname))]
  if (yname != as.character(formula)[2]) {
    varName <- c(yname, varName)
  }

  SISforest.compute(
    formula, Call, varName, X, y, criteria,ntrees, storeOOB,
    replacement, stratify, ratOOB, parallel,numCores, MaxDepth,
    numNode, MinLeaf, subset, weights, na.action,Xscale
  )

  # class(forest) = append(class(forest),"SISforest.formula")
  #return(forest)
}


#' @rdname SISforest
#' @method SISforest default
#' @aliases SISforest.default
#' @export
SISforest.default <- function(X, y, criteria=c('DCor',"Pearson", "CvM","MI","HHG","HSIC","Gini")[1],
                              ntrees = 100, storeOOB = TRUE, replacement = TRUE, stratify = TRUE, ratOOB = 0.368, parallel = TRUE,
                              numCores = Inf, MaxDepth = Inf, numNode = Inf, MinLeaf = 10, subset = NULL, weights = NULL, na.action = na.fail,
                              Xscale = "Min-max", ...) {
  Call <- match.call()
  indx <- match(c("X", "y", "subset", "na.action"), names(Call), nomatch = 0L) # , "weights"
  if (indx[[1]] == 0 || indx[[2]] == 0) {
    stop("A 'formula' or 'X', 'y' argument is required")
  } else {
    if (sum(match(class(X), c("data.frame", "matrix"), nomatch = 0L)) == 0) {
      stop("argument 'X' can only be the classes 'data.frame' or 'matrix'")
    }
    if (ncol(X) == 1) {
      stop("argument 'X' dimension must exceed 1")
    }

    if (is.null(colnames(X))) {
      colnames(X) <- paste0("X", seq_len(ncol(X)))
    }
    data <- data.frame(y = y, X)
    varName <- colnames(X)

    formula <- y~.
    Call$formula <- formula
    Call$data <- quote(data)
    Call$X <- NULL
    Call$y <- NULL
  }

  SISforest.compute(
    formula, Call, varName, X, y, criteria,ntrees, storeOOB,
    replacement, stratify, ratOOB, parallel,numCores, MaxDepth,
    numNode, MinLeaf, subset, weights, na.action,Xscale
  )
}

#' @useDynLib SIStree, .registration = TRUE
#' @import Rcpp
#' @import doParallel
#' @import foreach
#' @importFrom parallel detectCores makeCluster clusterSplit stopCluster
#' @importFrom stats model.frame model.extract model.matrix na.fail as.formula
#' @keywords internal
#' @noRd
SISforest.compute <- function(formula, Call, varName, X, y, criteria,ntrees, storeOOB,
                              replacement, stratify, ratOOB, parallel,numCores, MaxDepth,
                              numNode, MinLeaf, subset, weights, na.action,Xscale) {
  #if (ntrees == 1) {
  #  stop("argument 'ntrees' must exceed 1")
  #}
  if (is.factor(y) && (criteria %in%c("CvM","MI"))) {
    stop(paste0("When ", formula[[2]], " is a factor type, 'criteria' cannot take 'CvM' and 'MI'."))
  }
  if (!is.factor(y) && (criteria =="Gini")) {
    stop(paste0("When criteria = 'Gini' ", formula[[2]], " must be a factor type."))
  }

  MinLeaf <- (MinLeaf == 1) + MinLeaf
  if ((ratOOB <= 0) || !storeOOB) {
    stop("out-of-bag indices for each tree are not stored. ODRF must be called with storeOOB = TRUE.")
  }

  n <- length(y)
  p <- ncol(X)
  yname <- NULL
  if (length(varName) > p) {
    yname <- varName[1]
    varName <- varName[-1]
  }


  if (!is.numeric(X)){
    X=apply(X, 2, as.numeric)
  }
  X <- as.matrix(X)
  colnames(X) <- varName


  # address na values.
  data <- data.frame(y, X)
  if (any(is.na(as.list(data)))) {
    warning("NA values exist in data frame")
  }

  Call0 <- Call
  colnames(data) <- c(as.character(formula)[2], varName)
  if (!is.null(yname)) {
    colnames(data)[1] <- yname
    temp <- model.frame(formula, data, drop.unused.levels = TRUE)
    Terms <- attr(temp, "terms")

    colnames(data)[1] <- "y" # as.character(formula)[2]
    formula[[2]] <- quote(y)
    Call0$formula <- formula
  }

  indx <- match(c("formula", "data", "subset", "na.action"), names(Call0), nomatch = 0L)
  temp <- Call0[c(1L, indx)]
  temp[[1L]] <- quote(stats::model.frame)
  temp$drop.unused.levels <- TRUE
  temp <- eval(temp) # , parent.frame())
  Terms0 <- attr(temp, "terms")
  if (is.null(yname)) {
    Terms <- Terms0
    Call <- Call0
  }

  # data=model.frame(formula, data, drop.unused.levels = TRUE)
  # y <- data[,1]
  # X <- data[,-1]
  y <- c(model.extract(temp, "response"))
  X <- model.matrix(Terms0, temp)
  int <- match("(Intercept)", dimnames(X)[[2]], nomatch = 0)
  if (int > 0) {
    X <- X[, -int, drop = FALSE]
  }
  n <- length(y)
  p <- ncol(X)
  rm(data)


  Levels=NULL; numClass <- 1
  if (is.factor(y)) {
    Levels <- levels(y)
    #y <- as.integer(y)

    numClass <- length(Levels)
    if (numClass == 1) {
      stop("the number of factor levels of categorical response must be greater than one")
    }

    classCt <- cumsum(table(y))
    if (stratify) {
      Cindex <- vector("list", numClass)
      for (m in 1L:numClass) {
        Cindex[[m]] <- which(y == Levels[m])
      }
    }
  }

  # weights=c(weights,paramList$weights)
  if (!is.null(subset)) {
    weights <- weights[subset]
  }
  # if (!is.null(weights)) {
  #  X <- X * matrix(weights, n, p)
  # }

  # Variable scaling.
  minCol <- NULL
  maxminCol <- NULL
  if (Xscale != "No") {
    if (Xscale == "Min-max") {
      minCol <- apply(X, 2, min)
      maxminCol <- apply(X, 2, function(x) {
        max(x) - min(x)
      })
    }
    if (Xscale == "Quantile") {
      minCol <- apply(X, 2, quantile, 0.05)
      maxminCol <- apply(X, 2, function(x) {
        quantile(x, 0.95) - quantile(x, 0.05)
      })
    }
    maxminCol<-maxminCol+1e-06
    X <- (X - matrix(minCol, n, p, byrow = T)) / matrix(maxminCol, n, p, byrow = T)
  }


  #if(is.null(paramList$numProj)){paramList$numProj=ceiling(p/2)}
  #paramList <- defaults(paramList, split="mse", p, weights, catLabel)
  Forest <- list(call = Call, terms = Terms)
  Forest$data <- list(
    subset = subset, weights = weights, na.action = na.action, n = n, p = p, varName = varName,
    Xscale = Xscale, minCol = minCol, maxminCol = maxminCol
  )
  Forest$tree <- list(criteria = criteria, MaxDepth = MaxDepth, MinLeaf = MinLeaf, numNode = numNode)
  Forest$forest <- list(
    ntrees = ntrees, ratOOB = ratOOB, storeOOB = storeOOB, replacement = replacement, stratify = stratify,
    parallel = parallel, numCores = numCores
  )


  ##############################################################################
  #if("type"%in%names(Call0)){Call0=Call0[-which("type"==names(Call0))]}
  #mtry=ifelse(ntrees==1,p,paramList$numProj)
  runTree <- function(itree, ...) {
    #set.seed(seed + itree)

    seqn=seq(n)
    TDindx <- seqn
    if (replacement) {
      go <- TRUE
      while (go) {
        # make sure each class is represented in proportion to classes in initial dataset
        if (stratify && (is.factor(y))) {
          if (classCt[1L] != 0L) {
            TDindx[1:classCt[1L]] <- sample(Cindex[[1L]], classCt[1L], replace = TRUE)
          }
          for (z in 2:numClass) {
            if (classCt[z - 1L] != classCt[z]) {
              TDindx[(classCt[z - 1L] + 1L):classCt[z]] <- sample(Cindex[[z]], classCt[z] - classCt[z - 1L], replace = TRUE)
            }
          }
        } else {
          TDindx <- sample(seqn, n, replace = TRUE)
        }
        go <- all(seqn %in% TDindx)
      }
    } else {
      TDindx <- sample(seqn, ceiling(n * (1 - ratOOB)), replace = FALSE)
    }

    tree=SIStree.compute(formula, Call0, varName,X[TDindx,,drop=F], y[TDindx], criteria, MaxDepth, numNode, MinLeaf,
                         subset = NULL, weights = weights[TDindx], na.action = NULL, Xscale = "No")
  # if(ensemble=="allLayer")
     varDCor=tree$VarImp$SIStree
   #if(ensemble=="finalLayer")
     #varDCor=tree$VarImp$SIStree.layer[nrow(tree$VarImp$SIStree.layer),,drop=F]

    return(varDCor)
  }


  VALUE <- rep(0.0, p)
  if (parallel&&(ntrees>1)) {
    # RNGkind("L'Ecuyer-CMRG")
    if (is.infinite(numCores)) {
      # Use all but 1 core if numCores=0.
      numCores <- parallel::detectCores() - 1L # logical = FALSE
    }
    numCores <- min(numCores, ntrees)
    gc()

    # cl <- parallel::makePSOCKcluster(num.cores)
    # library("SISforest1")
    # library(foreach)
    # foreach::registerDoSEQ()
    cl <- parallel::makeCluster(numCores, type = ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK"))
    chunks <- parallel::clusterSplit(cl, seq_len(ntrees))
    doParallel::registerDoParallel(cl, numCores)
    # set.seed(seed)
    icore <- NULL
    Votes <- foreach::foreach(
      icore = seq_along(chunks), .combine = 'cbind', .export = c("SIStree.compute","gini_split","fastdcor",
       'DCor',"Pearson", "CvM","MI","HHG","HSIC"),
      .packages = c("SIStree"), .noexport = "Forest"
    ) %dopar% {
      #lapply(chunks[[icore]], runTree)
      vapply(chunks[[icore]], runTree, VALUE)
    }
    doParallel::stopImplicitCluster()
    parallel::stopCluster(cl)
  } else {
    Votes <- vapply(1:ntrees, runTree, VALUE)
  }
  #options(op)
  ##############################################################################


  prob <- rep(1/ntrees,ntrees)
  forestVarCor <- c(Votes %*% prob)
  names(forestVarCor)=varName
  order.forestVar=order(forestVarCor,decreasing = TRUE)

  order.treeVar= t(apply(Votes,2,order,decreasing = TRUE))
  rownames(order.treeVar)=paste0("tree.",seq(ntrees))

  Forest$VarImp=list(rank.SISforest=order.forestVar,rank.SIStree=order.treeVar,SISforest=forestVarCor)#,probability=prob)

  class(Forest) <- append(class(Forest), "SISforest")
  return(Forest)
}

